**Частичное применение** - это способ понизить arity функции:

```
function partial(fn,...presetArgs) {
	return function partiallyApplied(...laterArgs){
		return fn( ...presetArgs, ...laterArgs );
	};
}
```

Пример использования:

Скажем есть ф-ия add:
```
function add(x,y) {
	return x + y;
}
```

и мы хотим вызвать её для каждого элемента массива, чтобы получить новый массив:

```
[1,2,3,4,5].map( function adder(val){
	return add( 3, val );
} );
// [4,5,6,7,8]
```

Мы не можем просто передать `add` в `map`, потому что сигнатура `add` не совпадает с той, которую
ожидает `map`. Если же использовать частичное применение:

```
[1,2,3,4,5].map( partial( add, 3 ) );
// [4,5,6,7,8]
```
мы изменяем сигнатуру `add` на нужную нам.

Другая техника, схожая с частничным применением называется **каррированием**. При каррировании
функция, принимающая несколько аргументов, разбибается на несколько последовательно вызывающихся
функций образовывающих цепочку вызовов. Каждая из этих функций принимает ровно один аргумент и возвращет функцию,
которая принимает следующий аргумент оригинальной функции. 

Пример использования (уже знакомый нам):

```
[1,2,3,4,5].map( curry( add )( 3 ) );
// [4,5,6,7,8]
```

```
function curry(fn,arity = fn.length) {
	return (function nextCurried(prevArgs){
		return function curried(nextArg){
			var args = prevArgs.concat( [nextArg] );

			if (args.length >= arity) {
				return fn( ...args );
			}
			else {
				return nextCurried( args );
			}
		};
	})( [] );
}
```

В чем разница между частичным применением и каррированием? Каррирование подходит для случая, когда заведомо известно, что будет
использована данная функция, но аргументов для неё еще нет:

```
var adder = curry( add );

// later
[1,2,3,4,5].map( adder( 3 ) );
// [4,5,6,7,8]
```

Т.о. Преимущество каррирования в том, что оно даёт возможность получить новую функцию, которая более спициализирована, и мы можем сохранить
и использовать эту новую функцию позднее в программе. Частичное применение, задает все частично примененные агрументы сразу же. Чтобы 
добиться того же эффекта, когда мы можем передавать в функцию параметры один за другим, по одному за раз, как при каррировании, используя 
частичное применение нам пришлось бы вызывать partialApply для каждой последующей функции снова и снова. Каррирование же делает это 
автоматически. 
В JS и каррирование, и частичное применение реализуются засчет замыканий.	

## Зачем?

В обоих случаях вызов функции выглядит более странным чем когда мы передаем все аргументы в функцию в одном месте.
Однако это дает преимущества:
1) это удобно когда по началу нам неизвестны все аргументы, и мы можем постепенно передавать их в функцию. 
2) Ф-ию легче включать в композицию, когда она ожидает всего один аргумент.

bookmark: https://github.com/getify/Functional-Light-JS/blob/master/ch3.md#currying-more-than-one-argument 

*Point-free* is a style of writing code that eliminates unnecessary verbosity
 of mapping parameters ("points") 
to arguments, with the goal of making easier to read/understand code.