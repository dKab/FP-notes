### Декларативный код выразительнее, чем императивный.

Декларативный код часто получается короче императивного. Меньше кода почти всегда значит меньше багов.

Декларативный код фокусируется на **результате** операции (foreach + lambda)

Императивный код фокусируется на том, как этот результат получается. (Итерирование массива с помощью цикла `for`)
Когда вы читаете императивный код вы должны *выполнить* его у себя в голове, чтобы понять. Конечный результат тоже конечно *закодирован* там,
но он не так очевиден, как в случае с декларативным.
Мы должны всегда стремиться писать **декларативный** код.

Функция с математической точки зрения это два набора значений соответствующих друг другу (для [f(x) = 2x^2 + 3] каждому входному
 значению (x) соответствует значение f(x)) Если это числа, то соответсвующие пары значений мы называем координатами и можем изобразить
  эти множества значений на графике. Это в ФП называют morphism. Набор значений каждое из которых соответствует другому значению из
   другого набора. ФП в каком-то смысле о том, чтобы думать о функциях и использовать функции как
    *функции* с этой *математической* точки зрения, в отличие от функций как *процедур*, где функция это просто набор команд. 

Во многих языках в т.ч. JS *функция* и *процедура* не отличаются на уровне синтаксиса. Разница в том, что процедура может не принимать входные параметры, или не возвращать значения.
В то время как *функция* всегда принимает что-то на вход и всегда возвращает какое-то значение.  

**Аргументы** - это значения, кот. мы передаем в функцию;
 **параметры** - это именованные переменные которые мы видим внутри ф-ии, которые получают значения аргументов. 

**Arity** - это число параметров в сигнатуре функции. Зачастую это столько аргументов вы хотите передать в неё.
В рантайме можно получить arity функции проверив свойство `length` у ссылки на функцию. 
Функция с arity = 1 называется унарной(unary) функией. В ФП мы хотим использовать унарные функции как можно больше.
Лучший способ сделать функцию унарной фактически, но оставив ей на практике возможность принимать любое количество именованных параметров
в JS это использовать деструктуризацию объекта:

```
function foo( {x,y} = {} ) {
    console.log( x, y );
}

foo( {
    y: 3
} );
```  
Фунция, которая принимает один параметр очень легко включается в композицю с другими функциями, в том смысле, что она может принять
возвращаемое значение другой функции.

Функция, которая принимает неопределенное количество аргументов называется *вариационной*(variadic) ф-ией.
```
function foo(...args) {
    // ..
}
```
Если хотите писать в функциональном стиле, вы должны стремиться предпочитать *функции* процедурам.

### Вывод функции (function output)

В JS функции всегда возвращают какое-то значение и обычно это и понимается под выводом ф-ии. Однако кроме
явного вывода, есть ещё неявный. Фунция может вернуть значение неявно изменив внешнюю переменную.
Если ф-ия меняет значение внешней переменной, это называется побочным действием. Функция которая не имеет
побочных действий называется чистой ф-ией. В ФП привествуется использование чистых ф-ий, а побочных действий
рекомендуется избегать любой ценой.

### Функции высшего порядка

Фунция, которая принимает или возвращает другую функцию называется *функией высшего порядка*

### Запоминание контекста

Когда функция, находящаяся внутри другой функции обращается к переменной из контекста внешней функции, это называется *замыканием*
Замыкание это когда функция запоминает и обращается к переменной, находящейся вне её собственного контекста, даже когда эта функция вызвана    
в другом контексте.

Две техники пошаговой передачи входных значений функции **Каррирование** и **частичное применение** реализуются засчет замыкания. 

в ES6 имя функции может быть выведено (inference) из того как она используется, но не всегда:

```
function foo(fn) {
	console.log( fn.name );
}

var x = function(){};

foo( x );				// x
foo( function(){} );
```

### This 

*this* - это неявный параметр функции, поэтому не стоит использовать this в функциях.

