### Декларативный код выразительнее, чем императивный.

Декларативный код код часто получается короче императивного. Меньше кода почти всегда значит меньше багов.

Декларативный код фокусируется на **результате** операции (foreach + lambda)

Императивный код фокусируется на том, как этот результат получается. (Итерирование массива с помощью цикла `for`)
Когда вы читаете императивный код вы должны *выполнить* его у себя в голове, чтобы понять. Конечный результат тоже конечно *закодирован* там,
но он не так очевиден, как в случае с декларативным.
Мы должны всегда стремиться писать **декларативный** код.

Функция с математической точки зрения это два набора значений соответствующих друг другу (для [f(x) = 2x^2 + 3] каждому входному
 значению (x) соответствует значение f(x)) Если это числа, то соответсвующие пары значений мы называем координатами и можем изобразить
  эти множества значений на графике. Это в ФП называют morphism. Набор значений каждое из которых соответствует другому значению из
   другого набора. ФП в каком-то смысле о том, чтобы думать о функциях и использовать функции как
    *функции* с этой *математической* точки зрения, в отличие от функций как *процедур*.

Во многих языках в т.ч. JS *функция* и *процедура* не отличаются на уровне синтаксиса. Разница в том, что процедура может не принимать входные параметры, или не возвращать значения.
В то время как *функция* всегда принимает что-то на вход и всегда возвращает какое-то значение.  

**Аргументы** - это значения, кот. мы передаем в функцию;
 **параметры** - это именованные переменные которые мы видим внутри ф-ии, которые получают значения аргументов. 

**Arity** - это число параметров в сигнатуре функции. Зачастую это столько аргументов вы хотите передать в неё.
В рантайме можно получить arity функции проверив свойство `length` у ссылки на функцию. 
Функция с arity = 1 называется унарной(unary) функией. В ФП мы хотим использовать унарные функции как можно больше.
Лучший способ сделать функцию унарной фактически, но оставив ей на практике возможность принимать любое количество именованных параметров
в JS это использовать деструктуризацию объекта:

```
function foo( {x,y} = {} ) {
    console.log( x, y );
}

foo( {
    y: 3
} );
```  
Фунция, которая принимает один параметр очень легко включается в композицю с другими функциями, в том смысле, что она может принять
возвращаемое значение другой функции.

Функция, которая принимает неопределенное количество аргументов называется *вариационной*(variadic) ф-ией.
```
function foo(...args) {
    // ..
}
```
Если хотите писать в функциональном стиле, вы должны стремиться предпочитать *функции* процедурам.

bookmark https://github.com/getify/Functional-Light-JS/blob/master/ch2.md#functions-varying-by-input


